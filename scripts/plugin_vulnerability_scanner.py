#!/usr/bin/env python3
"""
í”ŒëŸ¬ê·¸ì¸ ì·¨ì•½ì  ìŠ¤ìºë„ˆ
ì •ì  ë¶„ì„ì„ í†µí•œ ë³´ì•ˆ ì·¨ì•½ì  ê°ì§€ ë° ìˆ˜ì • ì œì•ˆ
"""

import ast
import re
import json
import logging
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime  # datetimeì€ ì‚¬ìš©ë¨
import hashlib

# import os # ë¯¸ì‚¬ìš©
# import sys # ë¯¸ì‚¬ìš©

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PluginVulnerabilityScanner:
    def __init__(self, base_path: str = "plugins"):
        self.base_path = Path(base_path)
        self.vulnerability_patterns = {
            "sql_injection": [
                r"execute\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
                r"query\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
                r"raw\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
            ],
            "xss": [
                r"innerHTML\s*=\s*\w+",
                r"document\.write\s*\(\s*\w+",
                r"eval\s*\(\s*\w+",
                r"innerText\s*=\s*\w+",
            ],
            "command_injection": [
                r"subprocess\.call\s*\(\s*\w+",
                r"os\.system\s*\(\s*\w+",
                r"subprocess\.Popen\s*\(\s*\w+",
                r"exec\s*\(\s*\w+",
            ],
            "path_traversal": [
                r"open\s*\(\s*[\"']\.\./",
                r"Path\s*\(\s*[\"']\.\./",
                r"file_path\s*\+\s*[\"']\.\./",
            ],
            "hardcoded_secrets": [
                r"password\s*=\s*[\"'][^\"']{8,}[\"']",
                r"secret\s*=\s*[\"'][^\"']{8,}[\"']",
                r"api_key\s*=\s*[\"'][^\"']{8,}[\"']",
                r"token\s*=\s*[\"'][^\"']{8,}[\"']",
            ],
            "weak_crypto": [
                r"md5\s*\(",
                r"sha1\s*\(",
                r"base64\s*\.\s*encode",
                r"base64\s*\.\s*decode",
            ],
        }

        self.security_policies = {
            "forbidden_imports": [
                "pickle",
                "marshal",
                "shelve",
                "dill",
                "subprocess",
                "os",
                "sys",
                "eval",
                "exec",
            ],
            "forbidden_functions": [
                "eval",
                "exec",
                "compile",
                "input",
                "raw_input",
                "__import__",
                "globals",
                "locals",
                "vars",
            ],
            "required_security_headers": [
                "Content-Security-Policy",
                "X-Content-Type-Options",
                "X-Frame-Options",
            ],
        }

    def scan_plugin_vulnerabilities(self, plugin_id: str) -> Dict[str, Any]:
        """í”ŒëŸ¬ê·¸ì¸ ì·¨ì•½ì  ìŠ¤ìº”"""
        try:
            plugin_path = self.base_path / plugin_id
            if not plugin_path.exists():
                return {"error": f"í”ŒëŸ¬ê·¸ì¸ {plugin_id}ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."}

            scan_results = {
                "plugin_id": plugin_id,
                "scanned_at": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "warnings": [],
                "security_score": 100,
                "file_analysis": {},
                "dependency_vulnerabilities": [],
                "policy_violations": [],
            }

            # Python íŒŒì¼ ì·¨ì•½ì  ìŠ¤ìº”
            for py_file in plugin_path.rglob("*.py"):
                file_analysis = self._analyze_file_vulnerabilities(py_file)
                scan_results["file_analysis"][
                    str(py_file.relative_to(plugin_path))
                ] = file_analysis

                # ì·¨ì•½ì  ì ìˆ˜ ê³„ì‚°
                if file_analysis["vulnerabilities"]:
                    scan_results["vulnerabilities"].extend(
                        file_analysis["vulnerabilities"]
                    )
                    scan_results["security_score"] -= (
                        len(file_analysis["vulnerabilities"]) * 15
                    )

                if file_analysis["warnings"]:
                    scan_results["warnings"].extend(file_analysis["warnings"])
                    scan_results["security_score"] -= len(file_analysis["warnings"]) * 5

            # ì˜ì¡´ì„± ì·¨ì•½ì  ê²€ì‚¬
            dependency_vulns = self._check_dependency_vulnerabilities(plugin_id)
            scan_results["dependency_vulnerabilities"] = dependency_vulns
            scan_results["security_score"] -= len(dependency_vulns) * 10

            # ë³´ì•ˆ ì •ì±… ê²€ì¦
            policy_violations = self._check_security_policies(plugin_id)
            scan_results["policy_violations"] = policy_violations
            scan_results["security_score"] -= len(policy_violations) * 5

            # ìµœì†Œ ë³´ì•ˆ ì ìˆ˜ ë³´ì¥
            scan_results["security_score"] = max(0, scan_results["security_score"])

            # ë³´ì•ˆ ë“±ê¸‰ ê²°ì •
            if scan_results["security_score"] >= 80:
                scan_results["security_grade"] = "A"
            elif scan_results["security_score"] >= 60:
                scan_results["security_grade"] = "B"
            elif scan_results["security_score"] >= 40:
                scan_results["security_grade"] = "C"
            else:
                scan_results["security_grade"] = "D"

            return scan_results

        except Exception as e:
            return {"error": f"ì·¨ì•½ì  ìŠ¤ìº” ì¤‘ ì˜¤ë¥˜: {e}"}

    def _analyze_file_vulnerabilities(self, file_path: Path) -> Dict[str, Any]:
        """íŒŒì¼ë³„ ì·¨ì•½ì  ë¶„ì„"""
        analysis = {
            "vulnerabilities": [],
            "warnings": [],
            "line_details": {},
            "file_hash": "",
        }

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()

            # íŒŒì¼ í•´ì‹œ ê³„ì‚°
            analysis["file_hash"] = hashlib.sha256(content.encode()).hexdigest()

            # ê° ì·¨ì•½ì  íŒ¨í„´ ê²€ì‚¬
            for vuln_type, patterns in self.vulnerability_patterns.items():
                for pattern in patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE)
                    for match in matches:
                        line_num = content[: match.start()].count("\n") + 1
                        line_content = content.split("\n")[line_num - 1].strip()

                        vulnerability = {
                            "type": vuln_type,
                            "line": line_num,
                            "column": match.start()
                            - content.rfind("\n", 0, match.start())
                            - 1,
                            "pattern": pattern,
                            "line_content": line_content,
                            "severity": (
                                "high"
                                if vuln_type in ["sql_injection", "command_injection"]
                                else "medium"
                            ),
                        }

                        analysis["vulnerabilities"].append(vulnerability)

                        if line_num not in analysis["line_details"]:
                            analysis["line_details"][line_num] = []
                        analysis["line_details"][line_num].append(vulnerability)

            # AST ê¸°ë°˜ ì¶”ê°€ ë¶„ì„
            try:
                tree = ast.parse(content)
                ast_vulns = self._analyze_ast_vulnerabilities(tree, content)
                analysis["vulnerabilities"].extend(ast_vulns)
            except SyntaxError:
                analysis["warnings"].append("êµ¬ë¬¸ ì˜¤ë¥˜ë¡œ ì¸í•œ AST ë¶„ì„ ì‹¤íŒ¨")

        except Exception as e:
            analysis["warnings"].append(f"íŒŒì¼ ë¶„ì„ ì˜¤ë¥˜: {e}")

        return analysis

    def _analyze_ast_vulnerabilities(
        self, tree: ast.AST, content: str
    ) -> List[Dict[str, Any]]:
        """AST ê¸°ë°˜ ì·¨ì•½ì  ë¶„ì„"""
        vulnerabilities = []

        for node in ast.walk(tree):
            # ê¸ˆì§€ëœ í•¨ìˆ˜ í˜¸ì¶œ ê²€ì‚¬
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    func_name = node.func.id
                    if func_name in self.security_policies["forbidden_functions"]:
                        line_num = node.lineno
                        line_content = content.split("\n")[line_num - 1].strip()

                        vulnerabilities.append(
                            {
                                "type": "forbidden_function",
                                "line": line_num,
                                "function": func_name,
                                "line_content": line_content,
                                "severity": "high",
                            }
                        )

            # ê¸ˆì§€ëœ import ê²€ì‚¬
            elif isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name in self.security_policies["forbidden_imports"]:
                        line_num = node.lineno
                        line_content = content.split("\n")[line_num - 1].strip()

                        vulnerabilities.append(
                            {
                                "type": "forbidden_import",
                                "line": line_num,
                                "module": alias.name,
                                "line_content": line_content,
                                "severity": "high",
                            }
                        )

            elif isinstance(node, ast.ImportFrom):
                if node.module in self.security_policies["forbidden_imports"]:
                    line_num = node.lineno
                    line_content = content.split("\n")[line_num - 1].strip()

                    vulnerabilities.append(
                        {
                            "type": "forbidden_import",
                            "line": line_num,
                            "module": node.module,
                            "line_content": line_content,
                            "severity": "high",
                        }
                    )

        return vulnerabilities

    def _check_dependency_vulnerabilities(self, plugin_id: str) -> List[Dict[str, Any]]:
        """ì˜ì¡´ì„± ì·¨ì•½ì  ê²€ì‚¬"""
        vulnerabilities = []

        try:
            plugin_path = self.base_path / plugin_id
            requirements_path = plugin_path / "config" / "requirements.txt"

            if not requirements_path.exists():
                return vulnerabilities

            with open(requirements_path, "r", encoding="utf-8") as f:
                requirements = [
                    line.strip()
                    for line in f
                    if line.strip() and not line.startswith("#")
                ]

            for requirement in requirements:
                # íŒ¨í‚¤ì§€ ì´ë¦„ ì¶”ì¶œ
                package_name = (
                    requirement.split("==")[0]
                    .split(">=")[0]
                    .split("<=")[0]
                    .split("~=")[0]
                )

                # ì•Œë ¤ì§„ ì·¨ì•½ì  íŒ¨í‚¤ì§€ ì²´í¬
                known_vulns = self._check_known_vulnerabilities(package_name)
                if known_vulns:
                    vulnerabilities.extend(known_vulns)

        except Exception as e:
            vulnerabilities.append(
                {
                    "type": "dependency_check_error",
                    "package": "unknown",
                    "error": str(e),
                    "severity": "medium",
                }
            )

        return vulnerabilities

    def _check_known_vulnerabilities(self, package_name: str) -> List[Dict[str, Any]]:
        """ì•Œë ¤ì§„ ì·¨ì•½ì  íŒ¨í‚¤ì§€ ê²€ì‚¬"""
        # ì‹¤ì œë¡œëŠ” ì™¸ë¶€ ì·¨ì•½ì  ë°ì´í„°ë² ì´ìŠ¤ APIë¥¼ ì‚¬ìš©í•´ì•¼ í•¨
        # ì—¬ê¸°ì„œëŠ” ì˜ˆì‹œë¡œ ëª‡ ê°€ì§€ ì•Œë ¤ì§„ ì·¨ì•½ì  íŒ¨í‚¤ì§€ë¥¼ ì²´í¬

        known_vulnerable_packages = {
            "requests": [
                {
                    "cve": "CVE-2023-32681",
                    "description": "HTTP header injection vulnerability",
                    "severity": "medium",
                    "affected_versions": "<2.31.0",
                }
            ],
            "urllib3": [
                {
                    "cve": "CVE-2023-45803",
                    "description": "CRLF injection vulnerability",
                    "severity": "medium",
                    "affected_versions": "<2.0.7",
                }
            ],
            "cryptography": [
                {
                    "cve": "CVE-2023-50782",
                    "description": "Timing attack vulnerability",
                    "severity": "low",
                    "affected_versions": "<41.0.8",
                }
            ],
        }

        if package_name.lower() in known_vulnerable_packages:
            return [
                {
                    "type": "known_vulnerability",
                    "package": package_name,
                    "vulnerabilities": known_vulnerable_packages[package_name.lower()],
                }
            ]

        return []

    def _check_security_policies(self, plugin_id: str) -> List[Dict[str, Any]]:
        """ë³´ì•ˆ ì •ì±… ê²€ì¦"""
        violations = []

        try:
            plugin_path = self.base_path / plugin_id

            # ì„¤ì • íŒŒì¼ ë³´ì•ˆ ê²€ì‚¬
            config_files = ["plugin.json", "config.json", "settings.json"]
            for config_file in config_files:
                config_path = plugin_path / "config" / config_file
                if config_path.exists():
                    with open(config_path, "r", encoding="utf-8") as f:
                        config_data = json.load(f)

                    # ë¯¼ê°í•œ ì •ë³´ ì²´í¬
                    sensitive_keys = [
                        "password",
                        "secret",
                        "api_key",
                        "token",
                        "private_key",
                    ]
                    for key in sensitive_keys:
                        if key in str(config_data).lower():
                            violations.append(
                                {
                                    "type": "sensitive_data_in_config",
                                    "file": config_file,
                                    "key": key,
                                    "severity": "high",
                                }
                            )

            # íŒŒì¼ ê¶Œí•œ ê²€ì‚¬
            for file_path in plugin_path.rglob("*"):
                if file_path.is_file():
                    # ì‹¤í–‰ ê¶Œí•œ ì²´í¬
                    if (
                        file_path.suffix not in [".py", ".sh", ".bat"]
                        and file_path.stat().st_mode & 0o111
                    ):
                        violations.append(
                            {
                                "type": "unnecessary_execute_permission",
                                "file": str(file_path.relative_to(plugin_path)),
                                "severity": "low",
                            }
                        )

        except Exception as e:
            violations.append(
                {"type": "policy_check_error", "error": str(e), "severity": "medium"}
            )

        return violations

    def generate_vulnerability_report(
        self, plugin_id: str, format: str = "json"
    ) -> str:
        """ì·¨ì•½ì  ë¦¬í¬íŠ¸ ìƒì„±"""
        try:
            # ì·¨ì•½ì  ìŠ¤ìº” ì‹¤í–‰
            scan_results = self.scan_plugin_vulnerabilities(plugin_id)
            if "error" in scan_results:
                return f"ì·¨ì•½ì  ìŠ¤ìº” ì‹¤íŒ¨: {scan_results['error']}"

            # ë¦¬í¬íŠ¸ ë°ì´í„° êµ¬ì„±
            report = {
                "report_info": {
                    "plugin_id": plugin_id,
                    "generated_at": datetime.utcnow().isoformat(),
                    "scanner_version": "1.0.0",
                },
                "scan_summary": {
                    "security_score": scan_results["security_score"],
                    "security_grade": scan_results["security_grade"],
                    "total_vulnerabilities": len(scan_results["vulnerabilities"]),
                    "total_warnings": len(scan_results["warnings"]),
                    "dependency_vulnerabilities": len(
                        scan_results["dependency_vulnerabilities"]
                    ),
                    "policy_violations": len(scan_results["policy_violations"]),
                },
                "detailed_results": scan_results,
            }

            # ì¶œë ¥ í˜•ì‹ì— ë”°ë¥¸ ì²˜ë¦¬
            if format == "json":
                report_path = Path("logs") / "vulnerability_reports"
                report_path.mkdir(parents=True, exist_ok=True)

                report_file = (
                    report_path
                    / f"vulnerability_report_{plugin_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
                )
                with open(report_file, "w", encoding="utf-8") as f:
                    json.dump(report, f, indent=2, ensure_ascii=False)

                return str(report_file)

            elif format == "html":
                return self._generate_html_vulnerability_report(report)

            else:
                return json.dumps(report, indent=2, ensure_ascii=False)

        except Exception as e:
            return f"ì·¨ì•½ì  ë¦¬í¬íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}"

    def _generate_html_vulnerability_report(self, report: Dict[str, Any]) -> str:
        """HTML ì·¨ì•½ì  ë¦¬í¬íŠ¸ ìƒì„±"""
        try:
            html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>ì·¨ì•½ì  ë¦¬í¬íŠ¸ - {report['report_info']['plugin_id']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
        .summary {{ margin: 20px 0; }}
        .vulnerability {{ margin: 10px 0; padding: 10px; border-left: 4px solid #ff4444; background-color: #fff5f5; }}
        .warning {{ margin: 10px 0; padding: 10px; border-left: 4px solid #ffaa00; background-color: #fffbf0; }}
        .grade-a {{ color: #00aa00; }}
        .grade-b {{ color: #aaaa00; }}
        .grade-c {{ color: #ffaa00; }}
        .grade-d {{ color: #ff4444; }}
        .code {{ background-color: #f5f5f5; padding: 5px; font-family: monospace; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>ì·¨ì•½ì  ë¦¬í¬íŠ¸</h1>
        <p><strong>í”ŒëŸ¬ê·¸ì¸:</strong> {report['report_info']['plugin_id']}</p>
        <p><strong>ìƒì„± ì‹œê°„:</strong> {report['report_info']['generated_at']}</p>
        <p><strong>ë³´ì•ˆ ì ìˆ˜:</strong> <span class="grade-{report['scan_summary']['security_grade'].lower()}">{report['scan_summary']['security_score']}/100 ({report['scan_summary']['security_grade']})</span></p>
    </div>
    
    <div class="summary">
        <h2>ìŠ¤ìº” ìš”ì•½</h2>
        <ul>
            <li>ì´ ì·¨ì•½ì : {report['scan_summary']['total_vulnerabilities']}ê°œ</li>
            <li>ì´ ê²½ê³ : {report['scan_summary']['total_warnings']}ê°œ</li>
            <li>ì˜ì¡´ì„± ì·¨ì•½ì : {report['scan_summary']['dependency_vulnerabilities']}ê°œ</li>
            <li>ì •ì±… ìœ„ë°˜: {report['scan_summary']['policy_violations']}ê°œ</li>
        </ul>
    </div>
"""

            # ì·¨ì•½ì  ìƒì„¸ ì •ë³´
            if report["detailed_results"]["vulnerabilities"]:
                html_content += "<h2>ì·¨ì•½ì  ìƒì„¸</h2>"
                for vuln in report["detailed_results"]["vulnerabilities"]:
                    html_content += f"""
    <div class="vulnerability">
        <h3>{vuln['type'].replace('_', ' ').title()}</h3>
        <p><strong>íŒŒì¼:</strong> {vuln.get('file', 'N/A')}</p>
        <p><strong>ë¼ì¸:</strong> {vuln.get('line', 'N/A')}</p>
        <p><strong>ì‹¬ê°ë„:</strong> {vuln.get('severity', 'unknown')}</p>
        <p><strong>ì½”ë“œ:</strong> <span class="code">{vuln.get('line_content', 'N/A')}</span></p>
    </div>
"""

            # ê²½ê³  ì •ë³´
            if report["detailed_results"]["warnings"]:
                html_content += "<h2>ê²½ê³ </h2>"
                for warning in report["detailed_results"]["warnings"]:
                    html_content += f"""
    <div class="warning">
        <p>{warning}</p>
    </div>
"""

            html_content += """
</body>
</html>
"""

            # HTML íŒŒì¼ ì €ì¥
            report_path = Path("logs") / "vulnerability_reports"
            report_path.mkdir(parents=True, exist_ok=True)

            report_file = (
                report_path
                / f"vulnerability_report_{report['report_info']['plugin_id']}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.html"
            )
            with open(report_file, "w", encoding="utf-8") as f:
                f.write(html_content)

            return str(report_file)

        except Exception as e:
            return f"HTML ë¦¬í¬íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}"

    def fix_vulnerabilities(
        self, plugin_id: str, auto_fix: bool = False
    ) -> Dict[str, Any]:
        """ì·¨ì•½ì  ìˆ˜ì • (ìë™/ìˆ˜ë™)"""
        try:
            # ì·¨ì•½ì  ìŠ¤ìº” ì‹¤í–‰
            scan_results = self.scan_plugin_vulnerabilities(plugin_id)
            if "error" in scan_results:
                return scan_results

            fixes_applied = []
            fixes_suggested = []

            # ê° ì·¨ì•½ì ì— ëŒ€í•œ ìˆ˜ì • ì œì•ˆ
            for vuln in scan_results["vulnerabilities"]:
                fix_suggestion = self._generate_fix_suggestion(vuln)

                if auto_fix and fix_suggestion["can_auto_fix"]:
                    # ìë™ ìˆ˜ì • ì ìš©
                    fix_result = self._apply_fix(plugin_id, vuln, fix_suggestion)
                    if fix_result["success"]:
                        fixes_applied.append(fix_result)
                else:
                    # ìˆ˜ë™ ìˆ˜ì • ì œì•ˆ
                    fixes_suggested.append(fix_suggestion)

            return {
                "success": True,
                "plugin_id": plugin_id,
                "fixes_applied": fixes_applied,
                "fixes_suggested": fixes_suggested,
                "total_fixes": len(fixes_applied) + len(fixes_suggested),
            }

        except Exception as e:
            return {"error": f"ì·¨ì•½ì  ìˆ˜ì • ì¤‘ ì˜¤ë¥˜: {e}"}

    def _generate_fix_suggestion(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """ì·¨ì•½ì  ìˆ˜ì • ì œì•ˆ ìƒì„±"""
        vuln_type = vulnerability["type"]

        suggestions = {
            "sql_injection": {
                "can_auto_fix": False,
                "suggestion": "ë§¤ê°œë³€ìˆ˜í™”ëœ ì¿¼ë¦¬ ì‚¬ìš©",
                "example": "cursor.execute('SELECT * FROM users WHERE id = %s', (user_id,))",
            },
            "xss": {
                "can_auto_fix": False,
                "suggestion": "ì…ë ¥ ë°ì´í„° ì´ìŠ¤ì¼€ì´í”„",
                "example": "html.escape(user_input)",
            },
            "command_injection": {
                "can_auto_fix": False,
                "suggestion": "subprocess ì‚¬ìš© ê¸ˆì§€, ì•ˆì „í•œ API ì‚¬ìš©",
                "example": "ëŒ€ì‹  os.path.join() ì‚¬ìš©",
            },
            "forbidden_function": {
                "can_auto_fix": True,
                "suggestion": "ì•ˆì „í•œ ëŒ€ì•ˆ í•¨ìˆ˜ ì‚¬ìš©",
                "example": "eval() ëŒ€ì‹  ast.literal_eval() ì‚¬ìš©",
            },
            "forbidden_import": {
                "can_auto_fix": True,
                "suggestion": "ì•ˆì „í•œ ëŒ€ì•ˆ ëª¨ë“ˆ ì‚¬ìš©",
                "example": "subprocess ëŒ€ì‹  pathlib ì‚¬ìš©",
            },
        }

        return suggestions.get(
            vuln_type,
            {"can_auto_fix": False, "suggestion": "ìˆ˜ë™ ê²€í†  í•„ìš”", "example": "N/A"},
        )

    def _apply_fix(
        self,
        plugin_id: str,
        vulnerability: Dict[str, Any],
        fix_suggestion: Dict[str, Any],
    ) -> Dict[str, Any]:
        """ìë™ ìˆ˜ì • ì ìš©"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íŒŒì¼ ìˆ˜ì • ë¡œì§ì´ í•„ìš”
            # ì—¬ê¸°ì„œëŠ” ì˜ˆì‹œë¡œë§Œ êµ¬í˜„

            return {
                "success": True,
                "vulnerability_type": vulnerability["type"],
                "fix_applied": fix_suggestion["suggestion"],
                "file": vulnerability.get("file", "unknown"),
                "line": vulnerability.get("line", 0),
            }

        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "vulnerability_type": vulnerability["type"],
            }


def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    scanner = PluginVulnerabilityScanner()

    print("ğŸ” í”ŒëŸ¬ê·¸ì¸ ì·¨ì•½ì  ìŠ¤ìºë„ˆ")
    print("=" * 50)

    while True:
        print("\nì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ëŠ¥:")
        print("1. ì·¨ì•½ì  ìŠ¤ìº”")
        print("2. ì·¨ì•½ì  ë¦¬í¬íŠ¸ ìƒì„±")
        print("3. ì·¨ì•½ì  ìˆ˜ì • ì œì•ˆ")
        print("4. ìë™ ì·¨ì•½ì  ìˆ˜ì •")
        print("0. ì¢…ë£Œ")

        choice = input("\nì„ íƒ (0-4): ").strip()

        if choice == "0":
            break
        elif choice == "1":
            plugin_id = input("í”ŒëŸ¬ê·¸ì¸ ID: ").strip()
            result = scanner.scan_plugin_vulnerabilities(plugin_id)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif choice == "2":
            plugin_id = input("í”ŒëŸ¬ê·¸ì¸ ID: ").strip()
            format_choice = (
                input("ì¶œë ¥ í˜•ì‹ (json/html/text, ê¸°ë³¸ê°’: json): ").strip() or "json"
            )
            report_path = scanner.generate_vulnerability_report(
                plugin_id, format_choice
            )
            print(f"ì·¨ì•½ì  ë¦¬í¬íŠ¸ ìƒì„± ì™„ë£Œ: {report_path}")
        elif choice == "3":
            plugin_id = input("í”ŒëŸ¬ê·¸ì¸ ID: ").strip()
            result = scanner.fix_vulnerabilities(plugin_id, auto_fix=False)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif choice == "4":
            plugin_id = input("í”ŒëŸ¬ê·¸ì¸ ID: ").strip()
            confirm = input("ìë™ ìˆ˜ì •ì„ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): ").strip().lower()
            if confirm == "y":
                result = scanner.fix_vulnerabilities(plugin_id, auto_fix=True)
                print(json.dumps(result, indent=2, ensure_ascii=False))
            else:
                print("ìë™ ìˆ˜ì •ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        else:
            print("âŒ ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.")


if __name__ == "__main__":
    main()
