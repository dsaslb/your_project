#!/usr/bin/env python3
"""
플러그인 취약점 스캐너
정적 분석을 통한 보안 취약점 감지 및 수정 제안
"""

import ast
import re
import json
import logging
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime  # datetime은 사용됨
import hashlib

# import os # 미사용
# import sys # 미사용

# 로깅 설정
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PluginVulnerabilityScanner:
    def __init__(self, base_path: str = "plugins"):
        self.base_path = Path(base_path)
        self.vulnerability_patterns = {
            "sql_injection": [
                r"execute\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
                r"query\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
                r"raw\s*\(\s*[\"'].*[\"']\s*\+\s*\w+",
            ],
            "xss": [
                r"innerHTML\s*=\s*\w+",
                r"document\.write\s*\(\s*\w+",
                r"eval\s*\(\s*\w+",
                r"innerText\s*=\s*\w+",
            ],
            "command_injection": [
                r"subprocess\.call\s*\(\s*\w+",
                r"os\.system\s*\(\s*\w+",
                r"subprocess\.Popen\s*\(\s*\w+",
                r"exec\s*\(\s*\w+",
            ],
            "path_traversal": [
                r"open\s*\(\s*[\"']\.\./",
                r"Path\s*\(\s*[\"']\.\./",
                r"file_path\s*\+\s*[\"']\.\./",
            ],
            "hardcoded_secrets": [
                r"password\s*=\s*[\"'][^\"']{8,}[\"']",
                r"secret\s*=\s*[\"'][^\"']{8,}[\"']",
                r"api_key\s*=\s*[\"'][^\"']{8,}[\"']",
                r"token\s*=\s*[\"'][^\"']{8,}[\"']",
            ],
            "weak_crypto": [
                r"md5\s*\(",
                r"sha1\s*\(",
                r"base64\s*\.\s*encode",
                r"base64\s*\.\s*decode",
            ],
        }

        self.security_policies = {
            "forbidden_imports": [
                "pickle",
                "marshal",
                "shelve",
                "dill",
                "subprocess",
                "os",
                "sys",
                "eval",
                "exec",
            ],
            "forbidden_functions": [
                "eval",
                "exec",
                "compile",
                "input",
                "raw_input",
                "__import__",
                "globals",
                "locals",
                "vars",
            ],
            "required_security_headers": [
                "Content-Security-Policy",
                "X-Content-Type-Options",
                "X-Frame-Options",
            ],
        }

    def scan_plugin_vulnerabilities(self, plugin_id: str) -> Dict[str, Any]:
        """플러그인 취약점 스캔"""
        try:
            plugin_path = self.base_path / plugin_id
            if not plugin_path.exists():
                return {"error": f"플러그인 {plugin_id}이 존재하지 않습니다."}

            scan_results = {
                "plugin_id": plugin_id,
                "scanned_at": datetime.utcnow().isoformat(),
                "vulnerabilities": [],
                "warnings": [],
                "security_score": 100,
                "file_analysis": {},
                "dependency_vulnerabilities": [],
                "policy_violations": [],
            }

            # Python 파일 취약점 스캔
            for py_file in plugin_path.rglob("*.py"):
                file_analysis = self._analyze_file_vulnerabilities(py_file)
                scan_results["file_analysis"][
                    str(py_file.relative_to(plugin_path))
                ] = file_analysis

                # 취약점 점수 계산
                if file_analysis["vulnerabilities"]:
                    scan_results["vulnerabilities"].extend(
                        file_analysis["vulnerabilities"]
                    )
                    scan_results["security_score"] -= (
                        len(file_analysis["vulnerabilities"]) * 15
                    )

                if file_analysis["warnings"]:
                    scan_results["warnings"].extend(file_analysis["warnings"])
                    scan_results["security_score"] -= len(file_analysis["warnings"]) * 5

            # 의존성 취약점 검사
            dependency_vulns = self._check_dependency_vulnerabilities(plugin_id)
            scan_results["dependency_vulnerabilities"] = dependency_vulns
            scan_results["security_score"] -= len(dependency_vulns) * 10

            # 보안 정책 검증
            policy_violations = self._check_security_policies(plugin_id)
            scan_results["policy_violations"] = policy_violations
            scan_results["security_score"] -= len(policy_violations) * 5

            # 최소 보안 점수 보장
            scan_results["security_score"] = max(0, scan_results["security_score"])

            # 보안 등급 결정
            if scan_results["security_score"] >= 80:
                scan_results["security_grade"] = "A"
            elif scan_results["security_score"] >= 60:
                scan_results["security_grade"] = "B"
            elif scan_results["security_score"] >= 40:
                scan_results["security_grade"] = "C"
            else:
                scan_results["security_grade"] = "D"

            return scan_results

        except Exception as e:
            return {"error": f"취약점 스캔 중 오류: {e}"}

    def _analyze_file_vulnerabilities(self, file_path: Path) -> Dict[str, Any]:
        """파일별 취약점 분석"""
        analysis = {
            "vulnerabilities": [],
            "warnings": [],
            "line_details": {},
            "file_hash": "",
        }

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()

            # 파일 해시 계산
            analysis["file_hash"] = hashlib.sha256(content.encode()).hexdigest()

            # 각 취약점 패턴 검사
            for vuln_type, patterns in self.vulnerability_patterns.items():
                for pattern in patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE)
                    for match in matches:
                        line_num = content[: match.start()].count("\n") + 1
                        line_content = content.split("\n")[line_num - 1].strip()

                        vulnerability = {
                            "type": vuln_type,
                            "line": line_num,
                            "column": match.start()
                            - content.rfind("\n", 0, match.start())
                            - 1,
                            "pattern": pattern,
                            "line_content": line_content,
                            "severity": (
                                "high"
                                if vuln_type in ["sql_injection", "command_injection"]
                                else "medium"
                            ),
                        }

                        analysis["vulnerabilities"].append(vulnerability)

                        if line_num not in analysis["line_details"]:
                            analysis["line_details"][line_num] = []
                        analysis["line_details"][line_num].append(vulnerability)

            # AST 기반 추가 분석
            try:
                tree = ast.parse(content)
                ast_vulns = self._analyze_ast_vulnerabilities(tree, content)
                analysis["vulnerabilities"].extend(ast_vulns)
            except SyntaxError:
                analysis["warnings"].append("구문 오류로 인한 AST 분석 실패")

        except Exception as e:
            analysis["warnings"].append(f"파일 분석 오류: {e}")

        return analysis

    def _analyze_ast_vulnerabilities(
        self, tree: ast.AST, content: str
    ) -> List[Dict[str, Any]]:
        """AST 기반 취약점 분석"""
        vulnerabilities = []

        for node in ast.walk(tree):
            # 금지된 함수 호출 검사
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    func_name = node.func.id
                    if func_name in self.security_policies["forbidden_functions"]:
                        line_num = node.lineno
                        line_content = content.split("\n")[line_num - 1].strip()

                        vulnerabilities.append(
                            {
                                "type": "forbidden_function",
                                "line": line_num,
                                "function": func_name,
                                "line_content": line_content,
                                "severity": "high",
                            }
                        )

            # 금지된 import 검사
            elif isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name in self.security_policies["forbidden_imports"]:
                        line_num = node.lineno
                        line_content = content.split("\n")[line_num - 1].strip()

                        vulnerabilities.append(
                            {
                                "type": "forbidden_import",
                                "line": line_num,
                                "module": alias.name,
                                "line_content": line_content,
                                "severity": "high",
                            }
                        )

            elif isinstance(node, ast.ImportFrom):
                if node.module in self.security_policies["forbidden_imports"]:
                    line_num = node.lineno
                    line_content = content.split("\n")[line_num - 1].strip()

                    vulnerabilities.append(
                        {
                            "type": "forbidden_import",
                            "line": line_num,
                            "module": node.module,
                            "line_content": line_content,
                            "severity": "high",
                        }
                    )

        return vulnerabilities

    def _check_dependency_vulnerabilities(self, plugin_id: str) -> List[Dict[str, Any]]:
        """의존성 취약점 검사"""
        vulnerabilities = []

        try:
            plugin_path = self.base_path / plugin_id
            requirements_path = plugin_path / "config" / "requirements.txt"

            if not requirements_path.exists():
                return vulnerabilities

            with open(requirements_path, "r", encoding="utf-8") as f:
                requirements = [
                    line.strip()
                    for line in f
                    if line.strip() and not line.startswith("#")
                ]

            for requirement in requirements:
                # 패키지 이름 추출
                package_name = (
                    requirement.split("==")[0]
                    .split(">=")[0]
                    .split("<=")[0]
                    .split("~=")[0]
                )

                # 알려진 취약점 패키지 체크
                known_vulns = self._check_known_vulnerabilities(package_name)
                if known_vulns:
                    vulnerabilities.extend(known_vulns)

        except Exception as e:
            vulnerabilities.append(
                {
                    "type": "dependency_check_error",
                    "package": "unknown",
                    "error": str(e),
                    "severity": "medium",
                }
            )

        return vulnerabilities

    def _check_known_vulnerabilities(self, package_name: str) -> List[Dict[str, Any]]:
        """알려진 취약점 패키지 검사"""
        # 실제로는 외부 취약점 데이터베이스 API를 사용해야 함
        # 여기서는 예시로 몇 가지 알려진 취약점 패키지를 체크

        known_vulnerable_packages = {
            "requests": [
                {
                    "cve": "CVE-2023-32681",
                    "description": "HTTP header injection vulnerability",
                    "severity": "medium",
                    "affected_versions": "<2.31.0",
                }
            ],
            "urllib3": [
                {
                    "cve": "CVE-2023-45803",
                    "description": "CRLF injection vulnerability",
                    "severity": "medium",
                    "affected_versions": "<2.0.7",
                }
            ],
            "cryptography": [
                {
                    "cve": "CVE-2023-50782",
                    "description": "Timing attack vulnerability",
                    "severity": "low",
                    "affected_versions": "<41.0.8",
                }
            ],
        }

        if package_name.lower() in known_vulnerable_packages:
            return [
                {
                    "type": "known_vulnerability",
                    "package": package_name,
                    "vulnerabilities": known_vulnerable_packages[package_name.lower()],
                }
            ]

        return []

    def _check_security_policies(self, plugin_id: str) -> List[Dict[str, Any]]:
        """보안 정책 검증"""
        violations = []

        try:
            plugin_path = self.base_path / plugin_id

            # 설정 파일 보안 검사
            config_files = ["plugin.json", "config.json", "settings.json"]
            for config_file in config_files:
                config_path = plugin_path / "config" / config_file
                if config_path.exists():
                    with open(config_path, "r", encoding="utf-8") as f:
                        config_data = json.load(f)

                    # 민감한 정보 체크
                    sensitive_keys = [
                        "password",
                        "secret",
                        "api_key",
                        "token",
                        "private_key",
                    ]
                    for key in sensitive_keys:
                        if key in str(config_data).lower():
                            violations.append(
                                {
                                    "type": "sensitive_data_in_config",
                                    "file": config_file,
                                    "key": key,
                                    "severity": "high",
                                }
                            )

            # 파일 권한 검사
            for file_path in plugin_path.rglob("*"):
                if file_path.is_file():
                    # 실행 권한 체크
                    if (
                        file_path.suffix not in [".py", ".sh", ".bat"]
                        and file_path.stat().st_mode & 0o111
                    ):
                        violations.append(
                            {
                                "type": "unnecessary_execute_permission",
                                "file": str(file_path.relative_to(plugin_path)),
                                "severity": "low",
                            }
                        )

        except Exception as e:
            violations.append(
                {"type": "policy_check_error", "error": str(e), "severity": "medium"}
            )

        return violations

    def generate_vulnerability_report(
        self, plugin_id: str, format: str = "json"
    ) -> str:
        """취약점 리포트 생성"""
        try:
            # 취약점 스캔 실행
            scan_results = self.scan_plugin_vulnerabilities(plugin_id)
            if "error" in scan_results:
                return f"취약점 스캔 실패: {scan_results['error']}"

            # 리포트 데이터 구성
            report = {
                "report_info": {
                    "plugin_id": plugin_id,
                    "generated_at": datetime.utcnow().isoformat(),
                    "scanner_version": "1.0.0",
                },
                "scan_summary": {
                    "security_score": scan_results["security_score"],
                    "security_grade": scan_results["security_grade"],
                    "total_vulnerabilities": len(scan_results["vulnerabilities"]),
                    "total_warnings": len(scan_results["warnings"]),
                    "dependency_vulnerabilities": len(
                        scan_results["dependency_vulnerabilities"]
                    ),
                    "policy_violations": len(scan_results["policy_violations"]),
                },
                "detailed_results": scan_results,
            }

            # 출력 형식에 따른 처리
            if format == "json":
                report_path = Path("logs") / "vulnerability_reports"
                report_path.mkdir(parents=True, exist_ok=True)

                report_file = (
                    report_path
                    / f"vulnerability_report_{plugin_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
                )
                with open(report_file, "w", encoding="utf-8") as f:
                    json.dump(report, f, indent=2, ensure_ascii=False)

                return str(report_file)

            elif format == "html":
                return self._generate_html_vulnerability_report(report)

            else:
                return json.dumps(report, indent=2, ensure_ascii=False)

        except Exception as e:
            return f"취약점 리포트 생성 중 오류: {e}"

    def _generate_html_vulnerability_report(self, report: Dict[str, Any]) -> str:
        """HTML 취약점 리포트 생성"""
        try:
            html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>취약점 리포트 - {report['report_info']['plugin_id']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
        .summary {{ margin: 20px 0; }}
        .vulnerability {{ margin: 10px 0; padding: 10px; border-left: 4px solid #ff4444; background-color: #fff5f5; }}
        .warning {{ margin: 10px 0; padding: 10px; border-left: 4px solid #ffaa00; background-color: #fffbf0; }}
        .grade-a {{ color: #00aa00; }}
        .grade-b {{ color: #aaaa00; }}
        .grade-c {{ color: #ffaa00; }}
        .grade-d {{ color: #ff4444; }}
        .code {{ background-color: #f5f5f5; padding: 5px; font-family: monospace; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>취약점 리포트</h1>
        <p><strong>플러그인:</strong> {report['report_info']['plugin_id']}</p>
        <p><strong>생성 시간:</strong> {report['report_info']['generated_at']}</p>
        <p><strong>보안 점수:</strong> <span class="grade-{report['scan_summary']['security_grade'].lower()}">{report['scan_summary']['security_score']}/100 ({report['scan_summary']['security_grade']})</span></p>
    </div>
    
    <div class="summary">
        <h2>스캔 요약</h2>
        <ul>
            <li>총 취약점: {report['scan_summary']['total_vulnerabilities']}개</li>
            <li>총 경고: {report['scan_summary']['total_warnings']}개</li>
            <li>의존성 취약점: {report['scan_summary']['dependency_vulnerabilities']}개</li>
            <li>정책 위반: {report['scan_summary']['policy_violations']}개</li>
        </ul>
    </div>
"""

            # 취약점 상세 정보
            if report["detailed_results"]["vulnerabilities"]:
                html_content += "<h2>취약점 상세</h2>"
                for vuln in report["detailed_results"]["vulnerabilities"]:
                    html_content += f"""
    <div class="vulnerability">
        <h3>{vuln['type'].replace('_', ' ').title()}</h3>
        <p><strong>파일:</strong> {vuln.get('file', 'N/A')}</p>
        <p><strong>라인:</strong> {vuln.get('line', 'N/A')}</p>
        <p><strong>심각도:</strong> {vuln.get('severity', 'unknown')}</p>
        <p><strong>코드:</strong> <span class="code">{vuln.get('line_content', 'N/A')}</span></p>
    </div>
"""

            # 경고 정보
            if report["detailed_results"]["warnings"]:
                html_content += "<h2>경고</h2>"
                for warning in report["detailed_results"]["warnings"]:
                    html_content += f"""
    <div class="warning">
        <p>{warning}</p>
    </div>
"""

            html_content += """
</body>
</html>
"""

            # HTML 파일 저장
            report_path = Path("logs") / "vulnerability_reports"
            report_path.mkdir(parents=True, exist_ok=True)

            report_file = (
                report_path
                / f"vulnerability_report_{report['report_info']['plugin_id']}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.html"
            )
            with open(report_file, "w", encoding="utf-8") as f:
                f.write(html_content)

            return str(report_file)

        except Exception as e:
            return f"HTML 리포트 생성 중 오류: {e}"

    def fix_vulnerabilities(
        self, plugin_id: str, auto_fix: bool = False
    ) -> Dict[str, Any]:
        """취약점 수정 (자동/수동)"""
        try:
            # 취약점 스캔 실행
            scan_results = self.scan_plugin_vulnerabilities(plugin_id)
            if "error" in scan_results:
                return scan_results

            fixes_applied = []
            fixes_suggested = []

            # 각 취약점에 대한 수정 제안
            for vuln in scan_results["vulnerabilities"]:
                fix_suggestion = self._generate_fix_suggestion(vuln)

                if auto_fix and fix_suggestion["can_auto_fix"]:
                    # 자동 수정 적용
                    fix_result = self._apply_fix(plugin_id, vuln, fix_suggestion)
                    if fix_result["success"]:
                        fixes_applied.append(fix_result)
                else:
                    # 수동 수정 제안
                    fixes_suggested.append(fix_suggestion)

            return {
                "success": True,
                "plugin_id": plugin_id,
                "fixes_applied": fixes_applied,
                "fixes_suggested": fixes_suggested,
                "total_fixes": len(fixes_applied) + len(fixes_suggested),
            }

        except Exception as e:
            return {"error": f"취약점 수정 중 오류: {e}"}

    def _generate_fix_suggestion(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """취약점 수정 제안 생성"""
        vuln_type = vulnerability["type"]

        suggestions = {
            "sql_injection": {
                "can_auto_fix": False,
                "suggestion": "매개변수화된 쿼리 사용",
                "example": "cursor.execute('SELECT * FROM users WHERE id = %s', (user_id,))",
            },
            "xss": {
                "can_auto_fix": False,
                "suggestion": "입력 데이터 이스케이프",
                "example": "html.escape(user_input)",
            },
            "command_injection": {
                "can_auto_fix": False,
                "suggestion": "subprocess 사용 금지, 안전한 API 사용",
                "example": "대신 os.path.join() 사용",
            },
            "forbidden_function": {
                "can_auto_fix": True,
                "suggestion": "안전한 대안 함수 사용",
                "example": "eval() 대신 ast.literal_eval() 사용",
            },
            "forbidden_import": {
                "can_auto_fix": True,
                "suggestion": "안전한 대안 모듈 사용",
                "example": "subprocess 대신 pathlib 사용",
            },
        }

        return suggestions.get(
            vuln_type,
            {"can_auto_fix": False, "suggestion": "수동 검토 필요", "example": "N/A"},
        )

    def _apply_fix(
        self,
        plugin_id: str,
        vulnerability: Dict[str, Any],
        fix_suggestion: Dict[str, Any],
    ) -> Dict[str, Any]:
        """자동 수정 적용"""
        try:
            # 실제 구현에서는 파일 수정 로직이 필요
            # 여기서는 예시로만 구현

            return {
                "success": True,
                "vulnerability_type": vulnerability["type"],
                "fix_applied": fix_suggestion["suggestion"],
                "file": vulnerability.get("file", "unknown"),
                "line": vulnerability.get("line", 0),
            }

        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "vulnerability_type": vulnerability["type"],
            }


def main():
    """메인 함수"""
    scanner = PluginVulnerabilityScanner()

    print("🔍 플러그인 취약점 스캐너")
    print("=" * 50)

    while True:
        print("\n사용 가능한 기능:")
        print("1. 취약점 스캔")
        print("2. 취약점 리포트 생성")
        print("3. 취약점 수정 제안")
        print("4. 자동 취약점 수정")
        print("0. 종료")

        choice = input("\n선택 (0-4): ").strip()

        if choice == "0":
            break
        elif choice == "1":
            plugin_id = input("플러그인 ID: ").strip()
            result = scanner.scan_plugin_vulnerabilities(plugin_id)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif choice == "2":
            plugin_id = input("플러그인 ID: ").strip()
            format_choice = (
                input("출력 형식 (json/html/text, 기본값: json): ").strip() or "json"
            )
            report_path = scanner.generate_vulnerability_report(
                plugin_id, format_choice
            )
            print(f"취약점 리포트 생성 완료: {report_path}")
        elif choice == "3":
            plugin_id = input("플러그인 ID: ").strip()
            result = scanner.fix_vulnerabilities(plugin_id, auto_fix=False)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif choice == "4":
            plugin_id = input("플러그인 ID: ").strip()
            confirm = input("자동 수정을 진행하시겠습니까? (y/N): ").strip().lower()
            if confirm == "y":
                result = scanner.fix_vulnerabilities(plugin_id, auto_fix=True)
                print(json.dumps(result, indent=2, ensure_ascii=False))
            else:
                print("자동 수정이 취소되었습니다.")
        else:
            print("❌ 잘못된 선택입니다.")


if __name__ == "__main__":
    main()
